From c48e683b29c3798b65d123542f5197e52fa4e35a Mon Sep 17 00:00:00 2001
From: linya14x <linx.yang@intel.com>
Date: Tue, 24 Dec 2024 14:16:48 +0800
Subject: [PATCH] media: i2c: add dv_timings api in lt6911uxe

and removed default cur_mode

Signed-off-by: linya14x <linx.yang@intel.com>
Signed-off-by: Dongcheng Yan <dongcheng.yan@intel.com>
Signed-off-by: zouxiaoh <xiaohong.zou@intel.com>
---
 drivers/media/i2c/lt6911uxe.c | 206 ++++++++++++++++++++++++++--------
 1 file changed, 157 insertions(+), 49 deletions(-)

diff --git a/drivers/media/i2c/lt6911uxe.c b/drivers/media/i2c/lt6911uxe.c
index 4b56611176f6..9702042718df 100644
--- a/drivers/media/i2c/lt6911uxe.c
+++ b/drivers/media/i2c/lt6911uxe.c
@@ -9,9 +9,12 @@
 #include <linux/module.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
+#include <linux/v4l2-dv-timings.h>
+
 #include <media/v4l2-cci.h>
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-device.h>
+#include <media/v4l2-dv-timings.h>
 #include <media/v4l2-event.h>
 #include <media/v4l2-fwnode.h>

@@ -19,9 +22,9 @@
 #define REG_CHIP_ID			CCI_REG16(0xe100)

 #define REG_ENABLE_I2C			CCI_REG8(0xe0ee)
-#define REG_PIX_CLK			CCI_REG24(0xe085)
+#define REG_HALF_PIX_CLK		CCI_REG24(0xe085)
 #define REG_BYTE_CLK			CCI_REG24(0xe092)
-#define REG_H_TOTAL			CCI_REG16(0xe088)
+#define REG_HALF_H_TOTAL		CCI_REG16(0xe088)
 #define REG_V_TOTAL			CCI_REG16(0xe08a)
 #define REG_HALF_H_ACTIVE		CCI_REG16(0xe08c)
 #define REG_V_ACTIVE			CCI_REG16(0xe08e)
@@ -33,14 +36,29 @@
 #define INT_VIDEO_DISAPPEAR		0x0
 #define INT_VIDEO_READY			0x1

-#define LT6911UXE_DEFAULT_WIDTH		3840
-#define LT6911UXE_DEFAULT_HEIGHT	2160
 #define LT6911UXE_DEFAULT_LANES		4
-#define LT6911UXE_DEFAULT_FPS		30
-#define LT6911UXE_MAX_LINK_FREQ		297000000
 #define LT9611_PAGE_CONTROL		0xff
 #define YUV422_8_BIT			0x7

+/*
+ * lt6911uxe provides editable EDID for customers, but only can be edited like
+ * updating flash. Due to this limitation, it is not possible to implement
+ * EDID support.
+ */
+
+static const struct v4l2_dv_timings_cap lt6911uxe_timings_cap_4kp30 = {
+	.type = V4L2_DV_BT_656_1120,
+	/* Pixel clock from REF_01 p. 20. Min/max height/width are unknown */
+	V4L2_INIT_BT_TIMINGS(
+		160, 3840,				/* min/max width */
+		120, 2160,				/* min/max height */
+		50000000, 594000000,			/* min/max pixelclock */
+		V4L2_DV_BT_STD_CEA861 | V4L2_DV_BT_STD_DMT |
+		V4L2_DV_BT_STD_CVT,
+		V4L2_DV_BT_CAP_PROGRESSIVE | V4L2_DV_BT_CAP_CUSTOM |
+		V4L2_DV_BT_CAP_REDUCED_BLANKING)
+};
+
 static const struct regmap_range_cfg lt9611uxe_ranges[] = {
 	{
 		.name = "register_range",
@@ -65,10 +83,13 @@ static const struct regmap_config lt9611uxe_regmap_config = {
 struct lt6911uxe_mode {
 	u32 width;
 	u32 height;
+	u32 htotal;
+	u32 vtotal;
 	u32 code;
 	u32 fps;
 	u32 lanes;
 	s64 link_freq;
+	u64 pixel_clk;
 };

 struct lt6911uxe {
@@ -77,7 +98,7 @@ struct lt6911uxe {
 	struct v4l2_ctrl_handler ctrl_handler;
 	struct v4l2_ctrl *pixel_rate;
 	struct v4l2_ctrl *link_freq;
-
+	struct v4l2_dv_timings timings;
 	struct lt6911uxe_mode cur_mode;
 	struct regmap *regmap;
 	struct gpio_desc *reset_gpio;
@@ -98,15 +119,6 @@ static inline struct lt6911uxe *to_lt6911uxe(struct v4l2_subdev *sd)
 	return container_of(sd, struct lt6911uxe, sd);
 }

-static const struct lt6911uxe_mode default_mode = {
-	.width = LT6911UXE_DEFAULT_WIDTH,
-	.height = LT6911UXE_DEFAULT_HEIGHT,
-	.code = MEDIA_BUS_FMT_UYVY8_1X16,
-	.fps = LT6911UXE_DEFAULT_FPS,
-	.lanes = LT6911UXE_DEFAULT_LANES,
-	.link_freq = LT6911UXE_MAX_LINK_FREQ,
-};
-
 static s64 get_pixel_rate(struct lt6911uxe *lt6911uxe)
 {
 	s64 pixel_rate;
@@ -119,48 +131,138 @@ static s64 get_pixel_rate(struct lt6911uxe *lt6911uxe)
 	return pixel_rate;
 }

+static int lt6911uxe_get_detected_timings(struct v4l2_subdev *sd,
+					  struct v4l2_dv_timings *timings)
+{
+	struct lt6911uxe *lt6911uxe = to_lt6911uxe(sd);
+	struct v4l2_bt_timings *bt = &timings->bt;
+
+	memset(timings, 0, sizeof(struct v4l2_dv_timings));
+
+	timings->type = V4L2_DV_BT_656_1120;
+
+	bt->width = lt6911uxe->cur_mode.width;
+	bt->height = lt6911uxe->cur_mode.height;
+	bt->vsync = lt6911uxe->cur_mode.vtotal - lt6911uxe->cur_mode.height;
+	bt->hsync = lt6911uxe->cur_mode.htotal - lt6911uxe->cur_mode.width;
+	bt->pixelclock = lt6911uxe->cur_mode.pixel_clk;
+
+	return 0;
+}
+
+static int lt6911uxe_s_dv_timings(struct v4l2_subdev *sd, unsigned int pad,
+				  struct v4l2_dv_timings *timings)
+{
+	struct lt6911uxe *lt6911uxe = to_lt6911uxe(sd);
+	struct v4l2_subdev_state *state;
+
+	state = v4l2_subdev_lock_and_get_active_state(sd);
+	if (v4l2_match_dv_timings(&lt6911uxe->timings, timings, 0, false))
+		return 0;
+
+	if (!v4l2_valid_dv_timings(timings, &lt6911uxe_timings_cap_4kp30,
+				   NULL, NULL)) {
+		v4l2_warn(sd, "timings out of range\n");
+		v4l2_subdev_unlock_state(state);
+		return -ERANGE;
+	}
+	lt6911uxe->timings = *timings;
+	v4l2_subdev_unlock_state(state);
+
+	return 0;
+}
+
+static int lt6911uxe_g_dv_timings(struct v4l2_subdev *sd, unsigned int pad,
+				  struct v4l2_dv_timings *timings)
+{
+	struct lt6911uxe *lt6911uxe = to_lt6911uxe(sd);
+	struct v4l2_subdev_state *state;
+
+	state = v4l2_subdev_lock_and_get_active_state(sd);
+
+	*timings = lt6911uxe->timings;
+	v4l2_subdev_unlock_state(state);
+
+	return 0;
+}
+
+static int lt6911uxe_query_dv_timings(struct v4l2_subdev *sd, unsigned int pad,
+				      struct v4l2_dv_timings *timings)
+{
+	struct v4l2_subdev_state *state;
+	int ret;
+
+	state = v4l2_subdev_lock_and_get_active_state(sd);
+	ret = lt6911uxe_get_detected_timings(sd, timings);
+	if (ret) {
+		v4l2_subdev_unlock_state(state);
+		return ret;
+	}
+
+	if (!v4l2_valid_dv_timings(timings, &lt6911uxe_timings_cap_4kp30,
+				   NULL, NULL)) {
+		v4l2_warn(sd, "timings out of range\n");
+		v4l2_subdev_unlock_state(state);
+		return -ERANGE;
+	}
+
+	v4l2_subdev_unlock_state(state);
+	return 0;
+}
+
+static int lt6911uxe_enum_dv_timings(struct v4l2_subdev *sd,
+				     struct v4l2_enum_dv_timings *timings)
+{
+	return v4l2_enum_dv_timings_cap(timings,
+			&lt6911uxe_timings_cap_4kp30, NULL, NULL);
+}
+
+static int lt6911uxe_dv_timings_cap(struct v4l2_subdev *sd,
+				    struct v4l2_dv_timings_cap *cap)
+{
+	*cap = lt6911uxe_timings_cap_4kp30;
+	return 0;
+}
+
 static int lt6911uxe_status_update(struct lt6911uxe *lt6911uxe)
 {
 	struct i2c_client *client = v4l2_get_subdevdata(&lt6911uxe->sd);
 	u64 int_event;
-	u64 byte_clk, pixel_clk, fps, format;
-	u64 htotal, vtotal, half_width, height;
-	int timeout_cnt = 3;
+	u64 byte_clk, half_pix_clk, fps, format;
+	u64 half_htotal, vtotal, half_width, height;
 	int ret = 0;

 	/* Read interrupt event */
 	cci_read(lt6911uxe->regmap, REG_INT_HDMI, &int_event, &ret);
-	while (ret && timeout_cnt--) {
-		ret = cci_read(lt6911uxe->regmap, REG_INT_HDMI,
-				&int_event, NULL);
+	if (ret) {
+		dev_err(&client->dev, "failed to read interrupt event: %d\n",
+			ret);
+		return ret;
 	}

-	if (ret)
-		return dev_err_probe(&client->dev, ret,
-				     "failed to read interrupt event\n");
-
-	/* TODO: add audio ready and disappear type */
 	switch (int_event) {
 	case INT_VIDEO_READY:
 		cci_read(lt6911uxe->regmap, REG_BYTE_CLK, &byte_clk, &ret);
 		byte_clk *= 1000;
-		cci_read(lt6911uxe->regmap, REG_PIX_CLK, &pixel_clk, &ret);
-		pixel_clk *= 1000;
+		cci_read(lt6911uxe->regmap, REG_HALF_PIX_CLK,
+			 &half_pix_clk, &ret);
+		half_pix_clk *= 1000;

-		if (ret || byte_clk == 0 || pixel_clk == 0) {
+		if (ret || byte_clk == 0 || half_pix_clk == 0) {
 			dev_err(&client->dev,
 				"invalid ByteClock or PixelClock\n");
 			return -EINVAL;
 		}

-		cci_read(lt6911uxe->regmap, REG_H_TOTAL, &htotal, &ret);
+		cci_read(lt6911uxe->regmap, REG_HALF_H_TOTAL,
+			 &half_htotal, &ret);
 		cci_read(lt6911uxe->regmap, REG_V_TOTAL, &vtotal, &ret);
-		if (ret || htotal == 0 || vtotal == 0) {
+		if (ret || half_htotal == 0 || vtotal == 0) {
 			dev_err(&client->dev, "invalid htotal or vtotal\n");
 			return -EINVAL;
 		}

-		fps = div_u64(pixel_clk, htotal * vtotal);
+		fps = div_u64(half_pix_clk, half_htotal * vtotal);
 		if (fps > 60) {
 			dev_err(&client->dev,
 				"max fps is 60, current fps: %llu\n", fps);
@@ -184,11 +286,15 @@ static int lt6911uxe_status_update(struct lt6911uxe *lt6911uxe)
 			dev_err(&client->dev, "invalid MIPI format\n");
 			return -EINVAL;
 		}
+
 		lt6911uxe->cur_mode.height = height;
 		lt6911uxe->cur_mode.width = half_width * 2;
 		lt6911uxe->cur_mode.fps = fps;
 		/* MIPI Clock Rate = ByteClock Ã— 4, defined in lt6911uxe spec */
 		lt6911uxe->cur_mode.link_freq = byte_clk * 4;
+		lt6911uxe->cur_mode.pixel_clk = half_pix_clk * 2;
+		lt6911uxe->cur_mode.vtotal = vtotal;
+		lt6911uxe->cur_mode.htotal = half_htotal * 2;
 		v4l2_subdev_notify_event(&lt6911uxe->sd,
 					 &lt6911uxe_ev_source_change);
 		break;
@@ -210,7 +316,6 @@ static int lt6911uxe_status_update(struct lt6911uxe *lt6911uxe)
 	return ret;
 }

-/* TODO: add audio sampling rate and present control */
 static int lt6911uxe_init_controls(struct lt6911uxe *lt6911uxe)
 {
 	struct v4l2_ctrl_handler *ctrl_hdlr;
@@ -368,8 +473,8 @@ static int lt6911uxe_enum_frame_size(struct v4l2_subdev *sd,
 }

 static int lt6911uxe_enum_frame_interval(struct v4l2_subdev *sd,
-		struct v4l2_subdev_state *sd_state,
-		struct v4l2_subdev_frame_interval_enum *fie)
+				struct v4l2_subdev_state *sd_state,
+				struct v4l2_subdev_frame_interval_enum *fie)
 {
 	struct lt6911uxe *lt6911uxe = to_lt6911uxe(sd);

@@ -406,6 +511,11 @@ static const struct v4l2_subdev_pad_ops lt6911uxe_pad_ops = {
 	.enum_frame_size = lt6911uxe_enum_frame_size,
 	.enum_frame_interval = lt6911uxe_enum_frame_interval,
 	.get_frame_interval = v4l2_subdev_get_frame_interval,
+	.s_dv_timings = lt6911uxe_s_dv_timings,
+	.g_dv_timings = lt6911uxe_g_dv_timings,
+	.query_dv_timings = lt6911uxe_query_dv_timings,
+	.enum_dv_timings = lt6911uxe_enum_dv_timings,
+	.dv_timings_cap = lt6911uxe_dv_timings_cap,
 };

 static const struct v4l2_subdev_core_ops lt6911uxe_subdev_core_ops = {
@@ -457,6 +567,8 @@ static int lt6911uxe_fwnode_parse(struct lt6911uxe *lt6911uxe,
 		dev_err(dev, "only 4 data lanes are currently supported\n");
 		goto out_err;
 	}
+	lt6911uxe->cur_mode.lanes = bus_cfg.bus.mipi_csi2.num_data_lanes;
+	lt6911uxe->cur_mode.code = MEDIA_BUS_FMT_UYVY8_1X16;

 	return 0;

@@ -524,9 +636,6 @@ static int lt6911uxe_probe(struct i2c_client *client)
 	if (!lt6911uxe)
 		return -ENOMEM;

-	/* define default mode: 4k@60fps, changed when interrupt occurs. */
-	lt6911uxe->cur_mode = default_mode;
-
 	lt6911uxe->regmap = devm_regmap_init_i2c(client,
 						 &lt9611uxe_regmap_config);
 	if (IS_ERR(lt6911uxe->regmap))
@@ -561,15 +670,14 @@ static int lt6911uxe_probe(struct i2c_client *client)

 	lt6911uxe->sd.dev = dev;
 	lt6911uxe->sd.internal_ops = &lt6911uxe_internal_ops;
-	lt6911uxe->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
-			       V4L2_SUBDEV_FL_HAS_EVENTS;
+	lt6911uxe->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
 	lt6911uxe->sd.entity.ops = &lt6911uxe_subdev_entity_ops;
 	lt6911uxe->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;
 	lt6911uxe->pad.flags = MEDIA_PAD_FL_SOURCE;
 	ret = media_entity_pads_init(&lt6911uxe->sd.entity, 1, &lt6911uxe->pad);
 	if (ret) {
 		dev_err(dev, "failed to init entity pads: %d\n", ret);
-		goto err_v4l2_ctrl_handler_free;
+		goto v4l2_ctrl_handler_free;
 	}

 	/*
@@ -583,7 +691,7 @@ static int lt6911uxe_probe(struct i2c_client *client)
 	ret = v4l2_subdev_init_finalize(&lt6911uxe->sd);
 	if (ret) {
 		dev_err(dev, "failed to init v4l2 subdev: %d\n", ret);
-		goto err_media_entity_cleanup;
+		goto media_entity_cleanup;
 	}

 	/* Setting irq */
@@ -595,29 +703,29 @@ static int lt6911uxe_probe(struct i2c_client *client)
 				   irq_pin_flags, NULL, lt6911uxe);
 	if (ret) {
 		dev_err(dev, "failed to request IRQ: %d\n", ret);
-		goto err_subdev_cleanup;
+		goto subdev_cleanup;
 	}

 	ret = v4l2_async_register_subdev_sensor(&lt6911uxe->sd);
 	if (ret) {
 		dev_err(dev, "failed to register V4L2 subdev: %d\n", ret);
-		goto err_free_irq;
+		goto free_irq;
 	}

 	return 0;

-err_free_irq:
+free_irq:
 	free_irq(gpiod_to_irq(lt6911uxe->irq_gpio), lt6911uxe);

-err_subdev_cleanup:
+subdev_cleanup:
 	v4l2_subdev_cleanup(&lt6911uxe->sd);

-err_media_entity_cleanup:
+media_entity_cleanup:
 	pm_runtime_disable(dev);
 	pm_runtime_set_suspended(dev);
 	media_entity_cleanup(&lt6911uxe->sd.entity);

-err_v4l2_ctrl_handler_free:
+v4l2_ctrl_handler_free:
 	v4l2_ctrl_handler_free(lt6911uxe->sd.ctrl_handler);

 	return ret;
--
2.34.1

