From d10429626178490de5733a51fa041b3747921ade Mon Sep 17 00:00:00 2001
From: zouxiaoh <xiaohong.zou@intel.com>
Date: Fri, 16 May 2025 14:40:46 +0800
Subject: [PATCH] media: pci: The order of return buffers should be FIFO.

Change Description:
return_buffers : use "list_first_entry", will get these logs in hal:
“CamHAL[ERR] DeviceBase: dequeueBuffer, CamBuf index isn't same with
index used by kernel
CamHAL[ERR] CaptureUnit: Device:Generic grab frame failed:-22”

The index order is changed from sequential to reverse after return_buffers.
The reason why the normal start&stop does not expose the problem is that
every Hal start will start the buffer index from 0 instead of continuing
to use the buffer index returned last stop.

So need return_buffers from the list of tail,
and need use the "list_last_entry".

Signed-off-by: linya14x <linx.yang@intel.com>
Signed-off-by: zouxiaoh <xiaohong.zou@intel.com>
---
 .../media/pci/intel/ipu6/ipu6-isys-queue.c    | 31 ++++++++++---------
 1 file changed, 16 insertions(+), 15 deletions(-)

diff --git a/drivers/media/pci/intel/ipu6/ipu6-isys-queue.c b/drivers/media/pci/intel/ipu6/ipu6-isys-queue.c
index b931c4374694..14868b1ab441 100644
--- a/drivers/media/pci/intel/ipu6/ipu6-isys-queue.c
+++ b/drivers/media/pci/intel/ipu6/ipu6-isys-queue.c
@@ -519,39 +519,40 @@ static void return_buffers(struct ipu6_isys_queue *aq,
 	unsigned long flags;

 	spin_lock_irqsave(&aq->lock, flags);
-	while (!list_empty(&aq->incoming)) {
+
+	/*
+	 * Something went wrong (FW crash / HW hang / not all buffers
+	 * returned from isys) if there are still buffers queued in active
+	 * queue. We have to clean up places a bit.
+	 */
+	while (!list_empty(&aq->active)) {
 		struct vb2_buffer *vb;

-		ib = list_first_entry(&aq->incoming, struct ipu6_isys_buffer,
-				      head);
+		ib = list_last_entry(&aq->active, struct ipu6_isys_buffer,
+				     head);
 		vb = ipu6_isys_buffer_to_vb2_buffer(ib);
+
 		list_del(&ib->head);
 		spin_unlock_irqrestore(&aq->lock, flags);

 		vb2_buffer_done(vb, state);

 		spin_lock_irqsave(&aq->lock, flags);
+		need_reset = true;
 	}

-	/*
-	 * Something went wrong (FW crash / HW hang / not all buffers
-	 * returned from isys) if there are still buffers queued in active
-	 * queue. We have to clean up places a bit.
-	 */
-	while (!list_empty(&aq->active)) {
+	while (!list_empty(&aq->incoming)) {
 		struct vb2_buffer *vb;

-		ib = list_first_entry(&aq->active, struct ipu6_isys_buffer,
-				      head);
+		ib = list_last_entry(&aq->incoming, struct ipu6_isys_buffer,
+				     head);
 		vb = ipu6_isys_buffer_to_vb2_buffer(ib);
-
 		list_del(&ib->head);
 		spin_unlock_irqrestore(&aq->lock, flags);

 		vb2_buffer_done(vb, state);

 		spin_lock_irqsave(&aq->lock, flags);
-		need_reset = true;
 	}

 	spin_unlock_irqrestore(&aq->lock, flags);
@@ -699,8 +700,8 @@ static int reset_start_streaming(struct ipu6_isys_video *av)

 	spin_lock_irqsave(&aq->lock, flags);
 	while (!list_empty(&aq->active)) {
-		struct ipu6_isys_buffer *ib = list_first_entry(&aq->active,
-			struct ipu6_isys_buffer, head);
+		struct ipu6_isys_buffer *ib = list_last_entry(&aq->active,
+							      struct ipu6_isys_buffer, head);

 		list_del(&ib->head);
 		list_add_tail(&ib->head, &aq->incoming);
--
2.43.0

